# 0.先完成一个小目标：

#### 0.1

 编写一个MBR 达到能够让U盘作为启动盘的情况下开机并打印硬件信息 5s后自动关机

​	0.1.1首先能做到U盘上有操作系统的识别
1. 将U盘的MBR的 512字节刷好 ; 
2. 利用BIOS的系统调用打印信息 
3. 利用BIOS的系统调用定时5s 自动关机;暂时没有找到具体的解决方法 暂时清空屏幕死循环等待

#### 0.2

光一个512字节的mbr满足不了我们的需求 我们应该扩充一下现有大小

​	0.2.1 首先尝试把更多的盘内信息导入到内存的指定位置：

1. 我们要先了解有哪些内存可以被我们使用而不会破坏bios做的工作![image-20230822203958754](https://gitee.com/TTaket/typora-image/raw/master/image-20230822203958754.png)
2. 选择地址 比如9000 把硬盘第二个扇区读取到内存的9000位置
3. 之后跳转到 9000的位置 就完成了内存的扩充

​	0.2.2 优化：

1. 我们可以尝试打印出来拷贝了多少个扇区以及拷贝的内容
   1. 问题一： 512的空间限制 要注意代码容量
   2. 问题二： 并没有一个合适的堆栈位置 所以要注意寄存器
   3. 问题三： 打印的信息过多的时候 要注意翻页问题
2. 分区表：
   1. 可以考虑添加分区表实现启动指定的操作系统

#### 0.3 

我们已经体验到了扩展出更多的扇区到内存 但是实际应用中我们通常会对磁盘进行分区这里就引入了分区方式 我们选择的是使用传统的MBR + BIOS 的分区方式 也就是三个主分区 一个扩展分区 由扩展分区再进一步向下 细分 现在 我们就将加入分区表到尾部的64字节

0.3.1 创建分区表：

 	1. 从扇区表中提取出来指定的Bootsect 并且加载到预设的内存处 读取空间由分区表指定（这一过程模拟了分区表选中分区并且加载对应操作系统的过程）
 	2. 进阶： 提供菜单 从两个操作系统中选择一个进行加载 并且检验效果 
     这一部分并不是在MBR中实现 而是在操作系统的Bootsect中实现 
     	1. 涉及到更多设计环节 比如现有代码段的覆盖 暂时先不实现
         手动更改活动分区

除了分区表之外 为了更好的后续的编译过程 我们需要更完整的Makefile所以我们要对Makefile进行更好的编写

0.3.2 更新makefile：

​	



